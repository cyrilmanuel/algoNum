<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <style>
        input[type=number] {
            width: 50px;
        }

        .topleftConfig {
            position: relative;
            float: left;
        }

        .topleftInfo {
            position: relative;
            float: left;
            margin-left: 50px;
        }
    </style>
    <title> Labo1- Convertisseur</title>
</head>

<body>
<h1>Résolution d’équations</h1>
<div class="topleftConfig">
    <p>
        <label for="minAxeX">Valeur min axe X </label>
        <input type="number" name="minAxeX" id="minAxeX" value="-10"/>

        <label for="maxAxeX">Valeur max axe X </label>
        <input type="number" name="maxAxeX" id="maxAxeX" value="10"/>
    </p>
    <p>
        <label for="minAxeY">Valeur min axe Y </label>
        <input type="number" name="minAxeY" id="minAxeY" value="-10"/>

        <label for="maxAxeY">Valeur max axe Y </label>
        <input type="number" name="maxAxeY" id="maxAxeY" value="10"/>
    </p>
    <p>
        <label for="HEQUARTDGRASDUASION">Écart de graduation</label>
        <input type="number" name="HEQUARTDGRASDUASION" id="HEQUARTDGRASDUASION" value="1"/>

        <label for="choixGraine">Valeur de la graine </label>
        <input type="number" name="choixGraine" id="choixGraine" value="0.5"/>
    </p>
    <p>
        <button type="button" name="dessinerFonction1" id="dessinerFonction1">Dessiner f1(x)</button>
        <button type="button" name="dessinerFonction2" id="dessinerFonction2">Dessiner f2(x)</button>
        <button type="button" name="dessinerAnimation" id="dessinerAnimation">Dessiner Animation</button>
    </p>
</div>

<div class="topleft">
    <p>
            <textarea rows="4" cols="50" name="textarea" id="textarea" readonly> modifier les axes et choisisez la fonction.
            </textarea>
    </p>
</div>

<canvas id="myCanvas" width="1000" height="500">
    <!-- Message pour les navigateurs ne supportant pas encore canvas. -->
    Votre navigateur ne supporte pas encore les canvas. Essayez de metre-à-jour votre navigateur
    ou de changer de navigateur.
</canvas>
<script>

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //----------- DEFINITION DES FONCTIONS CLICK ET CHANGE --------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    document.getElementById("dessinerFonction1").addEventListener("click", function () {
        myGraph.function1Draw = true;
        clearAllGraph();
    });
    document.getElementById("dessinerFonction2").addEventListener("click", function () {
        myGraph.function1Draw = false;
        clearAllGraph();
    });
    document.getElementById("dessinerAnimation").addEventListener("click", function () {
        drawAnimation();
    });
    document.getElementById("minAxeX").addEventListener("change", function () {
        clearAllGraph();
    });
    document.getElementById("minAxeY").addEventListener("change", function () {
        clearAllGraph();
    });
    document.getElementById("maxAxeX").addEventListener("change", function () {
        clearAllGraph();
    });
    document.getElementById("maxAxeY").addEventListener("change", function () {
        clearAllGraph();
    });
    document.getElementById("choixGraine").addEventListener("change", function () {
        clearAllGraph();
    });
    document.getElementById("HEQUARTDGRASDUASION").addEventListener("change", function () {
        clearAllGraph();
    });

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //-------------------- CREATION DU GRAPHIQUE ------------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    function Graph(config) {

        // teste si le canvas et le context sont OK
        var canvas = document.getElementById('myCanvas');
        if (!canvas) alert("Impossible de récupérer le canvas");

        var context = canvas.getContext('2d');
        if (!context) alert("Impossible de récupérer le context du canvas");


        // Definition des propriété du graphique
        this.canvas = document.getElementById(config.canvasId);
        this.minX = config.minX;
        this.minY = config.minY;
        this.maxX = config.maxX;
        this.maxY = config.maxY;
        this.unitsPerTick = config.unitsPerTick;   // définition de l'écart des unitées affichées
        this.function1Draw = config.function1Draw;   // null si aucune, true si f1 dessiner, false si f2 dessiner
        this.tabXanimation = [];

        // execution des calculs et affichages des 2 axes
        this.drawAllAxes();
    }

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //------------- METHODE CALCUL ET DESSIN DES AXES -------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.drawAllAxes = function () {

        // constants pour les axes taille et police
        this.axisColor = '#aaa';
        this.font = '8pt Calibri';
        this.tickSize = 20;

        // récupération du contexte et calcul des valeurs utiles au dessin
        this.context = this.canvas.getContext('2d');
        this.rangeX = this.maxX - this.minX;
        this.rangeY = this.maxY - this.minY;

        // définition des pas de graduations
        this.unitX = this.canvas.width / this.rangeX;
        this.unitY = this.canvas.height / this.rangeY;

        // définition du centrage des axes X Y sur le canevas.
        this.centerY = Math.round(Math.abs(this.maxY / this.rangeY) * this.canvas.height);
        this.centerX = Math.round(Math.abs(this.minX / this.rangeX) * this.canvas.width);
        this.iteration = (this.maxX - this.minX) / 1000;
        this.scaleX = this.canvas.width / this.rangeX;
        this.scaleY = this.canvas.height / this.rangeY;

        // draw x and y axis
        this.drawXAxis();
        this.drawYAxis();
    }

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //------------- DESSIN DE L'AXE X ET DES GRADUATION -----------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.drawXAxis = function () {
        var context = this.context;
        context.save();
        context.beginPath();
        context.moveTo(0, this.centerY);
        context.lineTo(this.canvas.width, this.centerY);
        context.strokeStyle = this.axisColor;
        context.lineWidth = 2;
        context.stroke();

        // draw tick marks
        var xPosIncrement = this.unitsPerTick * this.unitX;
        var xPos, unit;
        context.font = this.font;
        context.textAlign = 'center';
        context.textBaseline = 'top';

        // draw left tick marks
        xPos = this.centerX - xPosIncrement;
        unit = -1 * this.unitsPerTick;
        while (xPos > 0) {
            context.moveTo(xPos, this.centerY - this.tickSize / 2);
            context.lineTo(xPos, this.centerY + this.tickSize / 2);
            context.stroke();
            context.fillText(unit, xPos, this.centerY + this.tickSize / 2 + 3);
            unit -= this.unitsPerTick;
            xPos = Math.round(xPos - xPosIncrement);
        }
        // draw right tick marks
        xPos = this.centerX + xPosIncrement;
        unit = this.unitsPerTick;
        while (xPos < this.canvas.width) {
            context.moveTo(xPos, this.centerY - this.tickSize / 2);
            context.lineTo(xPos, this.centerY + this.tickSize / 2);
            context.stroke();
            context.fillText(unit, xPos, this.centerY + this.tickSize / 2 + 3);
            unit += this.unitsPerTick;
            xPos = Math.round(xPos + xPosIncrement);
        }
        context.restore();
    };

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //------------- DESSIN DE L'AXE Y ET DES GRADUATION -----------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.drawYAxis = function () {
        var context = this.context;
        context.save();
        context.beginPath();
        context.moveTo(this.centerX, 0);
        context.lineTo(this.centerX, this.canvas.height);
        context.strokeStyle = this.axisColor;
        context.lineWidth = 2;
        context.stroke();

        // draw tick marks
        var yPosIncrement = this.unitsPerTick * this.unitY;
        var yPos, unit;
        context.font = this.font;
        context.textAlign = 'right';
        context.textBaseline = 'middle';

        // draw top tick marks
        yPos = this.centerY - yPosIncrement;
        unit = this.unitsPerTick;
        while (yPos > 0) {
            context.moveTo(this.centerX - this.tickSize / 2, yPos);
            context.lineTo(this.centerX + this.tickSize / 2, yPos);
            context.stroke();
            context.fillText(unit, this.centerX - this.tickSize / 2 - 3, yPos);
            unit += this.unitsPerTick;
            yPos = Math.round(yPos - yPosIncrement);
        }

        // draw bottom tick marks
        yPos = this.centerY + yPosIncrement;
        unit = -1 * this.unitsPerTick;
        while (yPos < this.canvas.height) {
            context.moveTo(this.centerX - this.tickSize / 2, yPos);
            context.lineTo(this.centerX + this.tickSize / 2, yPos);
            context.stroke();
            context.fillText(unit, this.centerX - this.tickSize / 2 - 3, yPos);
            unit -= this.unitsPerTick;
            yPos = Math.round(yPos + yPosIncrement);
        }
        context.restore();
    };

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //--------------- SUPPRESSION DES OBJETS DU CANVAS ------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.clearGraph = function () {
        // suppression des elements du canvas
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //--------------- TRANSFORMATION DES COORDONNEES --------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.transformContext = function () {
        var context = this.context;
        // move context to center of canvas
        this.context.translate(this.centerX, this.centerY);
        /*
         * stretch grid to fit the canvas window, and
         * invert the y scale so that that increments
         * as you move upwards
         */
        context.scale(this.scaleX, -this.scaleY);
    };

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //------------------ DESSIN D'UNE EQUATION DE X ---------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.drawEquation = function (equation, color, thickness) {

        var context = this.context;
        context.save();
        context.save();
        this.transformContext();
        context.beginPath();
        if (equation(this.minX) != null) context.moveTo(this.minX, equation(this.minX));

        // dessin de la fonction de x depuis Xmin jusqu'au Xmax
        for (var x = this.minX + this.iteration; x <= this.maxX; x += this.iteration) {
            if (equation(x) != null) context.lineTo(x, equation(x));
        }

        context.restore();
        context.lineJoin = 'round';
        context.lineWidth = thickness;
        context.strokeStyle = color;
        context.stroke();
        context.restore();

        // récupération du tableau contenant les différents x a dessinér pour l'animation.
        this.tabXanimation = Graph.prototype.newton(equation);
    };

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.newton = function (equation) {
        //doit Ítre rentrÈ par l'utilisateur
        var ecartMin = 0.0000001;
        var graine = parseFloat(document.getElementById("choixGraine").value);  // nb a choisir
        var nbMaxOcu = 10;

        var occurence = 0;
        var tabGraines = [];

        Graph.prototype.newtonRecursive(graine, equation, tabGraines, occurence, ecartMin);

        // pour afficher le tableau de graines
        /*
         for(var i = 0; i < tabGraines.length; i++) {
         alert("Graine : " + tabGraines[i]);
         }
        */

        var graineFinale = tabGraines[tabGraines.length - 1];
        if (graineFinale == null) {
            if (occurence > nbMaxOcu) {
                //alert("N'a pas convergÈ assez vite.");
                document.getElementById("textarea").value = "N'a pas convergÈ assez vite.";
            }
            else {
                document.getElementById("textarea").value = "Un graine n'Ètait pas valide (point stationnaire / asymptote hotizontale ou hors du domaine de dÈfinition).";
            }
        }
        else {
            document.getElementById("textarea").value = "Graine finale : " + Math.round(graineFinale / ecartMin) * ecartMin + " +/- " + ecartMin;
        }
        
        return tabGraines;
    }

    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.newtonRecursive = function (graine, fonction, tabGraine, occurence, ecartMin) {
        occurence++;
        //alert("Entrée dans newtonRecursive. Graine : " + graine);
        if (graine == null || graine < myGraph.minX || graine > myGraph.maxX) {
            //alert("Graine pas dans domaine du graph");
            document.getElementById("textarea").value = "Mauvais choix de la graine. ";
            return null; //mauvaise entrÈe
        }
        else {
            var sideGraine = graine + ecartMin;
            var fGraine = fonction(graine);
            var fSideGraine = fonction(sideGraine);

            //alert("SideGraine : " + sideGraine);
          //  alert("fGraine : " + fGraine);
            //alert("fSideGraine : " + fSideGraine);

            if (Math.abs(fGraine) <= ecartMin) {
                //alert("Trouvé la racine : " + graine);
                return graine;
            } //trouvÈ la racine
            else if (fGraine == null || fSideGraine == null || fGraine > myGraph.maxY || fGraine < myGraph.minY) {
                //alert("Graine en dehors du domaine de définition de la fonction");
                document.getElementById("textarea").value = "Graine hors du domaine de définition. ";
                return null; //graine pas dans domaine de dÈfinition
            }
            else {
                var newGraine, a, b; //y = a*x + b
                if (Math.abs(sideGraine - graine) < ecartMin / 2) {
                    //alert("Précision demanddée trop élevée");
                    return null;
                } //si ecartMin trop petit pour machine
                else {
                    a = (fSideGraine - fGraine) / (sideGraine - graine);
                    //alert("pente : " + a);
                    if (Math.abs(a) <= ecartMin) {
                        //alert("point stationnaire");
                        document.getElementById("textarea").value = "point stationnaire ou asymptote horizontale. ";
                        return null; //point stationnaire ou asymptote horizontale
                    }
                    else {
                        b = fGraine - a * graine;
                        //alert("b (ordonnée) : " + b);
                        newGraine = -(b / a);
                        //alert("Nouvelle graine : " + newGraine);
                        tabGraine.unshift(Graph.prototype.newtonRecursive(newGraine, fonction, tabGraine, occurence, ecartMin));
                        return graine; //une graine dans le processus
                    }
                }
            }
        }
    }


    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //------------ ANIMATION DE LA METHODE DE NEWTON --------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    Graph.prototype.Animation = function () {

        if (this.function1Draw != null) {
            var context = this.context;
            context.save();
            this.transformContext();
            context.beginPath();
            var graine = parseFloat(document.getElementById("choixGraine").value);
            context.moveTo(graine, 0);
            if (this.function1Draw == true) {
                context.lineTo(graine, graine / (1 - Math.pow(graine, 2)));
                // dessin de la methode de newton
                for (var i = 0; i < this.tabXanimation.length - 1; i += 1) {

                    //dessine la pente
                    context.lineTo(this.tabXanimation[i], 0);

                    if (i != (this.tabXanimation.length - 1)) {
                        context.lineTo(this.tabXanimation[i], this.tabXanimation[i] / (1 - Math.pow(this.tabXanimation[i], 2)));
                    }
                }
            } else {
                context.lineTo(graine, Math.sin(graine) - graine / 13);
                // dessin de la methode de newton
                for (var i = 0; i < this.tabXanimation.length; i += 1) {
                    // sleep(1000);
                    context.lineTo(this.tabXanimation[i], 0);
                    if (i != (this.tabXanimation.length - 1)) {
                        context.lineTo(this.tabXanimation[i], Math.sin(this.tabXanimation[i]) - this.tabXanimation[i] / 13);
                    }
                }
            }
            context.restore();
            context.lineWidth = 1;
            context.strokeStyle = 'green';
            context.stroke();
        } else {
            document.getElementById("textarea").value = "Veuillez séléctionner une fonction !";
        }
    }

    function sleep(milliseconds) {
        var start = new Date().getTime();
        for (var i = 0; i < 1e7; i++) {
            if ((new Date().getTime() - start) > milliseconds) {
                break;
            }
        }
    }
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------
    //------------------ UTILISATION ET AFFICHAGE -----------------------
    //-------------------------------------------------------------------
    //-------------------------------------------------------------------

    var recupMinX = parseInt(document.getElementById("minAxeX").value);
    var recupMinY = parseInt(document.getElementById("minAxeY").value);
    var recupMaxX = parseInt(document.getElementById("maxAxeX").value);
    var recupMaxY = parseInt(document.getElementById("maxAxeY").value);
    var recupGraduation = parseInt(document.getElementById("HEQUARTDGRASDUASION").value);

    var myGraph = new Graph({
        canvasId: 'myCanvas',
        minX: recupMinX,
        minY: recupMinY,
        maxX: recupMaxX,
        maxY: recupMaxY,
        unitsPerTick: 1,
        function1Draw: null
    });


    clearAllGraph = function () {
        myGraph.clearGraph();
        myGraph.minX = parseInt(document.getElementById("minAxeX").value);
        myGraph.minY = parseInt(document.getElementById("minAxeY").value);
        myGraph.maxX = parseInt(document.getElementById("maxAxeX").value);
        myGraph.maxY = parseInt(document.getElementById("maxAxeY").value);
        myGraph.unitsPerTick = parseInt(document.getElementById("HEQUARTDGRASDUASION").value);
        myGraph.drawAllAxes();

        switch (myGraph.function1Draw) {
            case true:
                drawFonc1();
                break;
            case false:
                drawFonc2();
                break;
            default:
                break;
        }
    }

    drawFonc1 = function () {
        myGraph.drawEquation(function (x) {
            var ecartMin = myGraph.iteration;
            if (Math.abs(1 - Math.pow(x, 2)) <= ecartMin) {
                return null;
            } else {
                return (x / (1 - Math.pow(x, 2)));
            }
        }, 'red', 1);
    }
    drawFonc2 = function () {

        myGraph.drawEquation(function (x) {
            return Math.sin(x) - x / 13;
        }, 'blue', 1);
    }

    drawAnimation = function () {
        myGraph.Animation();
    }
</script>
</body>
<h1>Résolution d’équations </h1>
<p>Sarah Groell, Cyril Jeanneret, Alexandre Serex et Nicolas Sommer Inf2 dlm­a</br> </p>

<p>Source pour du code pour la création du canevas de dessin : <a
        href="http://www.html5canvastutorials.com/labs/html5-canvas-graphing-an-equation/"> HTML5 CANEVAS</a>
<p>

<h2>But du programme</h2>
<p>Notre programme doit pouvoir afficher sous forme graphique, 2 fonctions définit dans le cours et trouver leur racines
    en utilisant la méthode de Newton</p>
<h2>Structure du programme</h2>

<h2>Méthode de la tangente ou méthode de Newton</h2>
<p>L'algorithme de la méthode de Newton est le suivant : </p>
<p>Pour toute fonction f(x) on peut choisir un point sur l'abscisse et trouver son image.
    On cherche ensuite la pente au niveau de ce point (par la dérivée ou par la méthode de Lagrange).
    On prolonge cette pente (qui deviendra donc une tangente au point f(x)) jusqu'à croiser à nouveau l'abscisse et l'on
    recommence les étapes précédentes jusqu'à trouver une image f(x) qui soit égal à 0.
    Cette méthode à toutefois un énorme inconvénient. Il est possible qu'avec un mauvais choix de graine cette méthode
    ne converge pas ou même finisse par créer une boucle infini.
    Cela se produit notamment lorsque la graine donne une image f(x) ou la pente de la courbe est trop faible.</p>
<p><strong>Précision sur la méthode de Lagrange qui a été utilisé dans ce programme: </strong></p>
<p>Il s'agit d'une méthode d'approximation de la pente par calcul sans avoir a passer par la dérivée.La formule de cette
    méthode nous a été donnée dans le cours.</p>
</html>
